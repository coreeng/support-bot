name: Trivy Security & License Scan

on:
  pull_request:
  push:

concurrency:
  group: security-scan-${{ github.head_ref }}
  cancel-in-progress: true

env:
  TRIVY_CACHE_DIR: /tmp/trivy-cache

jobs:
  security-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      actions: read
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: ${{ env.TRIVY_CACHE_DIR }}
          key: trivy-db-${{ runner.os }}-${{ hashFiles('**/build.gradle', '**/build.gradle.kts') }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: Run Vulnerability/Secret/Config Scan
        uses: aquasecurity/trivy-action@0.28.0
        continue-on-error: true
        with:
          scan-type: fs
          scan-ref: '.'
          output: trivy-results.json
          format: json
          scanners: vuln,config,secret
          ignore-unfixed: true
          severity: HIGH,CRITICAL
          cache-dir: ${{ env.TRIVY_CACHE_DIR }}

      - name: Run License Scan
        uses: aquasecurity/trivy-action@0.28.0
        continue-on-error: true
        with:
          scan-type: fs
          scan-ref: '.'
          output: trivy-license-results.json
          format: json
          scanners: license
          cache-dir: ${{ env.TRIVY_CACHE_DIR }}

      - name: Upload Trivy Scan Artifacts
        run: |
          mkdir -p trivy-artifacts
          cp trivy-results.json trivy-artifacts/
          cp trivy-license-results.json trivy-artifacts/
        uses: actions/upload-artifact@v3
        with:
          name: trivy-reports
          path: trivy-artifacts

      - name: Fail on Critical Misconfigurations
        run: |
          CRIT=$(jq '[.Results[]?.Misconfigurations[]? | select(.Severity=="CRITICAL")] | length' trivy-results.json)
          if [ "$CRIT" -gt 0 ]; then
            echo "❌ Critical misconfigurations found: $CRIT"
            exit 1
          fi

      - name: Fail on Critical Vulnerabilities
        run: |
          CRIT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-results.json)
          if [ "$CRIT" -gt 0 ]; then
            echo "❌ Critical vulnerabilities found: $CRIT"
            exit 1
          fi

      - name: Comment on PR with findings
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const files = [
              { path: 'trivy-results.json', type: 'Vulnerability/Secret/Config' },
              { path: 'trivy-license-results.json', type: 'License' }
            ];

            let comment = '# Complete Repository Security Scan Report\n\n';
            const now = new Date();
            comment += `**Date:** ${now.toISOString().split('T')[0]}\n`;
            comment += `**Branch:** ${context.payload.pull_request.head.ref}\n\n`;
            
            comment += `Artifacts: [trivy-reports](https://github.com/${context.repo.owner}/${context.repo.repo}/suites/${context.runId}/artifacts)\n\n`;

            for (const f of files) {
              if (!fs.existsSync(f.path)) {
                comment += `**${f.type} scan results not found.**\n\n`;
                continue;
              }

              const data = JSON.parse(fs.readFileSync(f.path, 'utf8'));
              let total = 0, vulns = 0, misconfigs = 0, secrets = 0, licenses = 0;

              for (const r of data.Results || []) {
                vulns += (r.Vulnerabilities?.length || 0);
                misconfigs += (r.Misconfigurations?.length || 0);
                secrets += (r.Secrets?.length || 0);
                licenses += (r.Licenses?.length || 0);
              }
              total = vulns + misconfigs + secrets + licenses;

              comment += `### ${f.type} Scan\n`;
              comment += '| Category | Count |\n|----------|-------|\n';
              comment += `| Vulnerabilities | ${vulns} |\n`;
              comment += `| Misconfigurations | ${misconfigs} |\n`;
              comment += `| Secrets | ${secrets} |\n`;
              comment += `| Licenses | ${licenses} |\n`;
              comment += `| **Total Issues** | **${total}** |\n\n`;

              // Vulnerabilities Details
              if (vulns > 0) {
                comment += `#### Vulnerabilities Details (Top 10 per target)\n| Severity | Package | Installed Version | Fixed Version | CVE |\n|----------|---------|-----------------|---------------|-----|\n`;
                for (const target of data.Results || []) {
                  if (!target.Vulnerabilities?.length) continue;
                  for (const v of target.Vulnerabilities.slice(0,10)) {
                    const fixedVersion = v.FixedVersion || '-';
                    const cveLink = v.VulnerabilityID ? `[${v.VulnerabilityID}](https://cve.mitre.org/cgi-bin/cvename.cgi?name=${v.VulnerabilityID})` : '-';
                    comment += `| ${v.Severity} | ${v.PkgName} | ${v.InstalledVersion} | ${fixedVersion} | ${cveLink} |\n`;
                  }
                  if (target.Vulnerabilities.length > 10) {
                    comment += `*...and ${target.Vulnerabilities.length - 10} more for ${target.Target}*\n`;
                  }
                }
                comment += '\n';
              }

              // Misconfigurations Details (all, collapsible)
              if (misconfigs > 0) {
                comment += `#### Misconfigurations Details\n| Severity | ID | Message |\n|----------|----|--------|\n`;
                for (const target of data.Results || []) {
                  if (!target.Misconfigurations?.length) continue;
                  for (const m of target.Misconfigurations) {
                    const safeMessage = (m.Message || '').replace(/\n/g, ' ');
                    comment += `| ${m.Severity} | ${m.ID} | <details><summary>View</summary>${safeMessage}</details> |\n`;
                  }
                }
                comment += '\n';
              }

              // Secrets Details (all, collapsible)
              if (secrets > 0) {
                comment += `#### Secrets Details\n| Rule | Match |\n|------|-------|\n`;
                for (const target of data.Results || []) {
                  if (!target.Secrets?.length) continue;
                  for (const s of target.Secrets) {
                    const safeMatch = (s.Match || '').replace(/\n/g, ' ');
                    comment += `| ${s.RuleID} | <details><summary>View</summary>${safeMatch}</details> |\n`;
                  }
                }
                comment += '\n';
              }

              // License Details
              if (f.type === 'License' && licenses > 0) {
                comment += `#### License Details\n| Package | License |\n|---------|---------|\n`;
                for (const target of data.Results || []) {
                  if (!target.Licenses?.length) continue;
                  for (const l of target.Licenses) {
                    comment += `| ${l.PkgName} | ${l.License} |\n`;
                  }
                }
                comment += '\n';
              }
            }

            if (files.every(f => !fs.existsSync(f.path))) {
              comment += '⚠️ No scan results found.\n';
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(c => c.body.startsWith('# Complete Repository Security Scan Report'));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
