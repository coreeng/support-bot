name: Trivy Security & License Scan

on:
  pull_request:
  push:
    branches:
      - main

concurrency:
  group: security-scan-${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }}
  cancel-in-progress: true

env:
  TRIVY_CACHE_DIR: /tmp/trivy-cache

jobs:
  security-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      actions: read
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: ${{ env.TRIVY_CACHE_DIR }}
          key: trivy-db-${{ runner.os }}-${{ hashFiles('**/build.gradle', '**/build.gradle.kts') }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: Run Vulnerability/Secret/Config Scan
        uses: aquasecurity/trivy-action@0.33.1
        continue-on-error: true
        with:
          scan-type: fs
          scan-ref: '.'
          output: trivy-results.json
          format: json
          scanners: vuln,config,secret
          ignore-unfixed: true
          severity: HIGH,CRITICAL
          cache-dir: ${{ env.TRIVY_CACHE_DIR }}
          trivy-config: trivy.yaml

      - name: Run License Scan
        uses: aquasecurity/trivy-action@0.33.1
        continue-on-error: true
        with:
          scan-type: fs
          scan-ref: '.'
          output: trivy-license-results.json
          format: json
          scanners: license
          cache-dir: ${{ env.TRIVY_CACHE_DIR }}
          trivy-config: trivy.yaml

      - name: Prepare Artifacts
        run: |
          mkdir -p trivy-artifacts
          cp trivy-results.json trivy-artifacts/
          cp trivy-license-results.json trivy-artifacts/

      - name: Upload Trivy Scan Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: trivy-reports
          path: trivy-artifacts


      - name: Post PR security report
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const repoUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}`;
            const headSha = context.payload.pull_request.head.sha;
            const cwd = process.cwd();
            const normalize = (p) => {
              if (!p) return null;
              try {
                if (p.startsWith(cwd + path.sep)) return p.slice(cwd.length + 1);
                return p.replace(/^\.\/?/, '');
              } catch { return p; }
            };
            const linkTo = (p, start, end) => {
              const rel = normalize(p);
              if (!rel) return '-';
              const anchor = start ? `#L${start}${end ? `-L${end}` : ''}` : '';
              return `[${rel}](${repoUrl}/blob/${headSha}/${encodeURI(rel)}${anchor})`;
            };

            const load = (p) => fs.existsSync(p) ? JSON.parse(fs.readFileSync(p, 'utf8')) : null;
            const vulnData = load('trivy-results.json');
            const licData = load('trivy-license-results.json');

            let reports = [];
            if (vulnData) reports.push({ type: 'Vulnerability/Secret/Config', data: vulnData });
            if (licData) reports.push({ type: 'License', data: licData });

            let totals = { vulns: 0, misconfigs: 0, secrets: 0, licenses: 0 };
            let criticals = { vulnCritical: 0, misconfCritical: 0 };

            for (const r of reports) {
              for (const res of (r.data.Results || [])) {
                const v = res.Vulnerabilities || [];
                const m = res.Misconfigurations || [];
                const s = res.Secrets || [];
                const l = res.Licenses || [];
                totals.vulns += v.length;
                totals.misconfigs += m.length;
                totals.secrets += s.length;
                totals.licenses += l.length;
                criticals.vulnCritical += v.filter(it => it.Severity === 'CRITICAL').length;
                criticals.misconfCritical += m.filter(it => it.Severity === 'CRITICAL').length;
              }
            }

            const totalIssues = totals.vulns + totals.misconfigs + totals.secrets + totals.licenses;
            const willFailWorkflow = (criticals.vulnCritical + criticals.misconfCritical) > 0;
            const wholeCheckPassed = totalIssues === 0;

            let comment = '# Complete Repository Security Scan Report\n\n';
            const now = new Date();
            comment += `Date: ${now.toISOString().split('T')[0]}\nBranch: ${context.payload.pull_request.head.ref}\n\n`;
            comment += `📦 [Download full Trivy reports](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n`;

            if (!vulnData && !licData) {
              comment += '⚠️ No scan results found.\n';
            }

            comment += '### Status\n';
            comment += `${wholeCheckPassed ? '✅' : '❌'} Overall: ${wholeCheckPassed ? 'no issues found' : 'issues found'}\n`;
            comment += `${willFailWorkflow ? '❌' : '✅'} Workflow: ${willFailWorkflow ? 'fail (critical issues found)' : 'pass (no critical issues)'}\n\n`;

            for (const report of reports) {
              let vulns = 0, misconfigs = 0, secrets = 0, licenses = 0;
              for (const r of report.data.Results || []) {
                vulns += (r.Vulnerabilities?.length || 0);
                misconfigs += (r.Misconfigurations?.length || 0);
                secrets += (r.Secrets?.length || 0);
                licenses += (r.Licenses?.length || 0);
              }
              const subtotal = vulns + misconfigs + secrets + licenses;

              comment += `### ${report.type} Scan\n`;
              comment += '| Category | Count |\n|----------|-------|\n';
              comment += `| Vulnerabilities | ${vulns} |\n`;
              comment += `| Misconfigurations | ${misconfigs} |\n`;
              comment += `| Secrets | ${secrets} |\n`;
              comment += `| Licenses | ${licenses} |\n`;
              comment += `| **Total Issues** | **${subtotal}** |\n\n`;

              if (vulns > 0) {
                comment += `#### Vulnerabilities (top 10 per file)\n| Severity | Package | Installed | Fixed | CVE | File |\n|----------|---------|----------|-------|-----|------|\n`;
                for (const target of report.data.Results || []) {
                  if (!target.Vulnerabilities?.length) continue;
                  for (const v of target.Vulnerabilities.slice(0,10)) {
                    const fixedVersion = v.FixedVersion || '-';
                    const cveLink = v.VulnerabilityID ? `[${v.VulnerabilityID}](https://cve.mitre.org/cgi-bin/cvename.cgi?name=${v.VulnerabilityID})` : '-';
                    const fileCell = linkTo(target.Target || '-', null, null);
                    comment += `| ${v.Severity} | ${v.PkgName} | ${v.InstalledVersion} | ${fixedVersion} | ${cveLink} | ${fileCell} |\n`;
                  }
                  if (target.Vulnerabilities.length > 10) {
                    comment += `*...and ${target.Vulnerabilities.length - 10} more for ${target.Target}*\n`;
                  }
                }
                comment += '\n';
              }

              if (misconfigs > 0) {
                comment += `#### Misconfigurations Details\n| Severity | ID | File | Lines | Resource | Message |\n|----------|----|------|-------|----------|---------|\n`;
                for (const target of report.data.Results || []) {
                  if (!target.Misconfigurations?.length) continue;
                  for (const m of target.Misconfigurations) {
                    const cm = m.CauseMetadata || {};
                    const file = cm.File || cm.Path || target.Target || '-';
                    const start = cm.StartLine ?? cm.startLine ?? '';
                    const end = cm.EndLine ?? cm.endLine ?? '';
                    const lines = (start || end) ? `${start || ''}${end ? '-' + end : ''}` : '-';
                    const resource = m.Resource || cm.Resource || '-';
                    const safeMessage = (m.Message || m.Title || '').replace(/\n/g, ' ');
                    const fileCell = linkTo(file, start, end);
                    comment += `| ${m.Severity} | ${m.ID} | ${fileCell} | ${lines} | ${resource} | ${safeMessage} |\n`;
                  }
                }
                comment += '\n';
              }

              if (secrets > 0) {
                comment += `#### Secrets Details\n| Rule | File | Line | Match |\n|------|------|------|-------|\n`;
                for (const target of report.data.Results || []) {
                  if (!target.Secrets?.length) continue;
                  for (const s of target.Secrets) {
                    const file = s.FilePath || s.File || target.Target || '-';
                    const line = s.StartLine ?? s.startLine ?? '-';
                    const safeMatch = (s.Match || s.Title || '').replace(/\n/g, ' ');
                    const fileCell = linkTo(file, line, line);
                    comment += `| ${s.RuleID} | ${fileCell} | ${line} | ${safeMatch} |\n`;
                  }
                }
                comment += '\n';
              }

              if (report.type === 'License' && licenses > 0) {
                comment += `#### License Details\n| Package | License | File |\n|---------|---------|------|\n`;
                for (const target of report.data.Results || []) {
                  if (!target.Licenses?.length) continue;
                  for (const l of target.Licenses) {
                    const fileCell = linkTo(target.Target || '-', null, null);
                    comment += `| ${l.PkgName} | ${l.License} | ${fileCell} |\n`;
                  }
                }
                comment += '\n';
              }
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body.startsWith('# Complete Repository Security Scan Report'));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

      - name: Fail on Critical Misconfigurations
        run: |
          CRIT=$(jq '[.Results[]?.Misconfigurations[]? | select(.Severity=="CRITICAL")] | length' trivy-results.json)
          if [ "$CRIT" -gt 0 ]; then
          echo "❌ Critical misconfigurations found: $CRIT"
          exit 1
          fi

      - name: Fail on Critical Vulnerabilities
        run: |
          CRIT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-results.json)
          if [ "$CRIT" -gt 0 ]; then
            echo "❌ Critical vulnerabilities found: $CRIT"
            exit 1
          fi
